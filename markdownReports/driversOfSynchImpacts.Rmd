---
title: "Drivers of synchrony impacts"
author: "Cam Freshwater"
date: "February 6, 2019"
output: html_document
---

This is a rehash of the cuSpecificPMs_altSynchOMs.Rmd intended to address co-authors question about why high levels of synchrony result in reduced aggregate spawner abundance. Specifically, whether this is solely an artifact of using a skewed multivariate distribution are shared sources of mortality (i.e. en route and exploitation within an MU). To explore these impacts run four scenarios.

1) Reference
2) noExp - no exploitation
3) noMM - no migration (en route) mortality
4) noBoth - no exploitation OR migration mortality

Begin by examining reference productivity scenario to understand impacts of mortality OMs independently of productivity.

```{r readLibraries, message=FALSE, warning=FALSE, include=FALSE}
listOfPackages <- c("here", "parallel", "doParallel", "foreach", 
                    "tidyverse", "tictoc", "samSim", "ggpubr")
newPackages <- listOfPackages[!(listOfPackages %in% 
                                  installed.packages()[ , "Package"])]
if (length(newPackages)) {
  install.packages(newPackages)
}
lapply(listOfPackages, require, character.only = TRUE)

simPar <- read.csv(here("data", "sox",
                         "fraserOMInputs_varyCorrNoMort.csv"),
                       stringsAsFactors = F)
cuPar <- read.csv(here("data/sox/fraserCUpars.csv"), stringsAsFactors=F)
srDat <- read.csv(here("data/sox/fraserRecDatTrim.csv"), stringsAsFactors=F)
catchDat <- read.csv(here("data/sox/fraserCatchDatTrim.csv"), stringsAsFactors=F)
ricPars <- read.csv(here("data/sox/pooledRickerMCMCPars.csv"), stringsAsFactors=F)
larkPars <- read.csv(here("data/sox/pooledLarkinMCMCPars.csv"), stringsAsFactors=F)
tamFRP <- read.csv(here("data/sox/tamRefPts.csv"), stringsAsFactors=F)

simParTrim <- simPar %>% 
  filter(scenario %in% c("ref", "noExp", "noMM", "noBoth"))
  # filter(prodRegime == "skew")

scenNames <- unique(simParTrim$scenario)
dirNames <- sapply(scenNames, function(x) paste(x, unique(simParTrim$species),
                                                sep = "_"))
```


```{r runSim, eval=FALSE, warning=FALSE, include=FALSE}
# Define simulations to be run
# nTrials <- 100
# 
# for (i in seq_along(dirNames)) {
#   dirName <- dirNames[i]
#   d <- subset(simParTrim, scenario == scenNames[i])
#   simsToRun <- split(d, seq(nrow(d)))
#   Ncores <- detectCores()
#   cl <- makeCluster(Ncores - 1) #save one core
#   registerDoParallel(cl)
#   clusterEvalQ(cl, c(library(samSim)))
#   clusterExport(cl, c("simsToRun","cuPar","nTrials","dirName",
#                       "catchDat","srDat","ricPars","larkPars",
#                       "tamFRP"), envir=environment())
#   tic("run in parallel")
#   parLapply(cl, simsToRun, function(x) {
#     recoverySim(x, cuPar, catchDat=catchDat, srDat=srDat, variableCU=FALSE,
#                 ricPars, larkPars=larkPars, tamFRP=tamFRP, dirName=dirName,
#                 nTrials=nTrials, makeSubDirs=FALSE, random=FALSE)
#     })
#   stopCluster(cl) #end cluster
#   toc()
# }
```


```{r plotPMs, echo=TRUE, warning=FALSE}
vars <- c("medRecRY", "ppnCUUpper", "ppnCUExtant",
          "medCatch", "ppnYrsHighCatch", "stabilityCatch", 
          "medSpawners")
omNames <- scenNames

plotDat = NULL
for(h in seq_along(dirNames)) {
  agList <- genOutputList(dirNames[h], agg = TRUE)
  keyVar <- sapply(agList, function(x) unique(x$keyVar))
  plotOrder <- sapply(agList, function(x) unique(x$plotOrder))
  singleScen = NULL
  for (i in seq_along(vars)) {
    dum <- data.frame(om = rep(omNames[h], length.out = length(agList)),
                      var = rep(vars[i], length.out = length(agList)),
                      synch = as.factor(keyVar),
                      cat = as.factor(plotOrder),
                      avg = sapply(agList, function(x) median(x[,vars[i]])),
                      lowQ = sapply(agList, function(x) qLow(x[,vars[i]])),
                      highQ = sapply(agList, function(x) qHigh(x[,vars[i]])),
                      row.names = NULL
    )
    singleScen <- rbind(singleScen, dum)
  }
  rownames(singleScen) <- c()
  #merge multiple scenarios into one dataframe
  plotDat <- rbind(plotDat, singleScen) 
}

temp <- plotDat %>%
    filter(var == "medSpawners")
dotSize = 3; lineSize = 0.8; legSize = 0.8; axSize = 10

ggplot(temp, aes(x = synch, y = avg, ymin = lowQ, ymax = highQ)) +
    labs(x = "Synchrony Treatment", y = unique(temp$var), 
         color = "Sim.\nParameter\nValue") +
    geom_pointrange(fatten = dotSize, size = lineSize,
                    position = position_dodge(width = 0.65)) +
    facet_wrap(~om, scales = "fixed")
```

Declines in aggregate PMs still occur even under reference scenarios when both processes are taken out. Look into CU-specific relationships for any insight.

####Plot CU-specific PMs
```{r cuSpecificPMs, echo=TRUE}
#Now generate violin plots showing trends in spawner abundance across different
#synchrony treatments.
omNames <- scenNames
stkNames <- genOutputList(dirNames[1], 
                          agg = FALSE)[["medSynch_TAM"]][["stkName"]]
nCUs <- length(stkNames)

#First generate data and plots for different synch treatments
fullPlotList <- list()
for (i in seq_along(dirNames)) { #make dataframe
  cuList <- genOutputList(dirNames[i], agg = FALSE)
  plotList <- lapply(cuList, function(h) {
    plotDat <- NULL
    nTrials <- nrow(h[["medSpawners"]])
    spwnDat <- data.frame(om = rep(omNames[i], length.out = nTrials * nCUs),
                          synch = rep(unique(h[["opMod"]]), 
                                      length.out = nTrials * nCUs)
    )
    spwn <- h[["medSpawners"]] %>%
      as.data.frame() 
    colnames(spwn) <- stkNames
    spwnLong <- spwn %>% 
      gather(key = cu, value = spawners) %>% 
      mutate(cu = as.factor(cu))
    plotDat <- rbind(plotDat, cbind(spwnDat, spwnLong))
    return(plotDat)
  })
  plotDat2 <- do.call(rbind, plotList)
  fullPlotList[[paste0(omNames[i])]] <- plotDat2
}
plotDat3 <- do.call(rbind, fullPlotList) %>%
  mutate(synch =  factor(synch, levels = c("lowSynch", "medSynch", 
                                           "highSynch"))) %>% 
  filter(cu %in% c("Bwrn", "Chlk", "Clts", "E.St", "Hrrs", "L.Sh", "Nadn",
                   "Qsnl", "Raft"))

p <- ggplot(plotDat3, aes(x = om, y = spawners, alpha = synch)) +
  geom_violin(draw_quantiles = c(0.5), position = position_dodge(width = 0.75),
              fill = "grey30") +
  scale_alpha_manual(name = "Synchrony OM", values = c(1, 0.65, 0.3)) +
  guides(alpha = guide_legend(override.aes = list(fill = "grey30"))) +
  theme_sleekX(facetSize = 1, axisSize = 12, legendSize = 0.85) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  facet_wrap(~cu, scales = "free_y")
p
```

No strong impact on CU-specific PMs which seems odd. Confirm by looking at a broader suite of characteristics.

####Plot stock-recruit relationships
```{r stockRecCurves, echo = FALSE}
stkNames <- genOutputList(dirNames[1], 
                          agg = FALSE)[["medSynch_TAM"]][["stkName"]]
#Focus on simplest scenario where both exploitation and en route mortality have been removed (i.e. dirNames[4])
arrayNames <- sapply(dirNames[4], function(x) { #matrix of array names to be passed
  list.files(paste(here("outputs/simData"), x, sep="/"), 
             pattern = "\\Arrays.RData$")
})
synchNames <- c("high", "low", "med")
colPal <- c("#b2182b", "#2166ac")
names(colPal) <- c("larkin", "ricker")

# Function to pull and clean array data
pullList <- function(arrayName, synchName, omName, var = "recDev") {
  #medSynch treatment only
  datList <- readRDS(paste(here("outputs/simData"), dirNames[4], arrayName, 
                           sep = "/"))
  datList[[var]] %>% 
    reshape2::melt() %>% 
    dplyr::rename("yr" = "Var1", "cu" =  "Var2", "trial" = "Var3", 
                  "var" = "value") %>% 
    mutate(synch = synchName, om = omName)
}

srList <- vector("list", length = length(arrayNames))
for (h in seq_along(arrayNames)) {
  sDat <- pullList(arrayNames[h], synchNames[h], omName = "noBoth", 
                   var = "S")
  rDat <- pullList(arrayNames[h], synchNames[h], omName = "noBoth", 
                   var = "recBY")
  srList[[h]] <- merge(sDat, rDat, by = c("yr", "cu", "trial", "synch", 
                                          "om")) %>% 
    rename("spwn" = "var.x", "recBY" = "var.y")
}

srFullDat <- do.call(rbind, srList) %>% 
  filter(!yr < 60) %>% #focus on median sig treatment, sim period
  mutate(synch = as.factor(synch), 
         model = case_when(
           cu %in% c(1, 2, 6, 8, 9) ~ "larkin",
           TRUE ~ "ricker"
         )) %>% 
  mutate(synch = factor(synch, levels(synch)[c(2,3,1)]))
omNames <- unique(srFullDat$om)

drawTrials <- sample.int(max(srFullDat$trial), size = 1)
plotList <- lapply(seq_along(stkNames[1:6]), function(i) { 
    dum <- srFullDat %>% 
      filter(trial == drawTrials,
             cu == i) 
    r <- ggplot(dum, aes(x = spwn, y = recBY, colour = model)) +
      labs(x = "Spawners", y = "Recruits", title = stkNames[i]) +
      geom_point(size = 1.25) +
      scale_colour_manual(name = "Stock Recruit Model", values = colPal, 
                          guide = FALSE) +
      theme_sleekX() +
      facet_wrap(~synch, nrow = 3, ncol = 1)
    return(r)
})

for (i in c(1, 4)) {
  srList <- ggarrange(plotList[[i]], plotList[[i+1]], plotList[[i+2]], 
            ncol = 3, nrow = 1, common.legend = TRUE, legend = "right", 
            align = "v", widths = c(1,1,1))
  annotate_figure(srList, 
                  left = text_grob("Recruits", rot = 90),
                  bottom = text_grob("Spawners"))
  print(srList)
}
```

Cyclic populations are shown in red, standard Ricker in blue but there are no patterns associated with either so effectively they can be ignored. There is no apparent impact of greater synchrony on reduced abundance, i.e. the SR curves aren't contracting. Check some more CU-specific PMs, including recruitment deviations (to see how changes in the covariance matrix influence the residuals that are generated) as well as realized productivity to see if they produce knock on effects.

```{r prepDevProdData, include=FALSE}
prodList <- vector("list", length = length(arrayNames))
for (h in seq_along(arrayNames)) {
  devDat <- pullList(arrayNames[h], synchNames[h], omName = "noBoth", 
                   var = "recDev") %>% 
    rename("value" = "var") %>% 
    mutate(var = "recDev")
  prodDat <- pullList(arrayNames[h], synchNames[h], omName = "noBoth", 
                   var = "logRS") %>% 
    rename("value" = "var") %>% 
    mutate(var = "logRS")
  prodList[[h]] <- rbind(devDat, prodDat) %>% 
    mutate(var = as.factor(var))
}

prodFullDat <- do.call(rbind, prodList) %>% 
  filter(!yr < 60) %>% #focus on sim period
  mutate(synch = as.factor(synch), 
         model = case_when(
           cu %in% c(1, 2, 6, 8, 9) ~ "larkin",
           TRUE ~ "ricker"
         )) %>% 
  mutate(synch = factor(synch, levels(synch)[c(2,3,1)]))
omNames <- unique(prodFullDat$om)
```

```{r plotDevs}
drawTrials <- sample.int(max(prodFullDat$trial), size = 1)
plotList <- lapply(seq_along(stkNames[1:6]), function(i) { 
    dum <- prodFullDat %>% 
      filter(trial == drawTrials,
             cu == i, 
             var == "recDev") %>% 
      group_by(synch) %>% 
      mutate(meanDev = mean(value))
    r <- ggplot(dum, aes(x = yr, y = value, colour = model)) +
      labs(x = "Time", y = "Recruitment Deviations", title = stkNames[i]) +
      geom_line(size = 1.25) +
      geom_hline(dum, mapping = aes(yintercept = meanDev), linetype = 2) +
      scale_colour_manual(name = "Stock Recruit Model", values = colPal, 
                          guide = FALSE) +
      theme_sleekX() +
      facet_wrap(~synch, nrow = 3, ncol = 1)
    return(r)
})

for (i in c(1, 4)) {
  devPlotList <- ggarrange(plotList[[i]], plotList[[i+1]], plotList[[i+2]], 
            ncol = 3, nrow = 1, common.legend = TRUE, legend = "right", 
            align = "v", widths = c(1,1,1))
  annotate_figure(devPlotList, 
                  left = text_grob("Recruits", rot = 90),
                  bottom = text_grob("Spawners"))
  print(devPlotList)
}

dum <- prodFullDat %>% 
  filter(var == "recDev") %>%
  group_by(cu, trial, synch, model) %>% 
  summarize(medRec = median(value),
            meanRec = mean(value))
ggplot(dum, aes(x = synch, y = medRec, colour = model)) +
  labs(x = "Time", y = "Median Recruitment Deviation Over Sim Period") +
  geom_boxplot() +
  scale_colour_manual(name = "Stock Recruit Model", values = colPal, 
                      guide = FALSE) +
  theme_sleekX() +
  facet_wrap(~cu, scale = "free_y")
```

Yes definitely no CU-specific patterns in recruitment deviations, but what about realized productivity?

```{r plotRealProd}
dum <- prodFullDat %>% 
  filter(var == "logRS") %>%
  group_by(cu, trial, synch, model) %>% 
  summarize(medProd = median(value),
            meanProd = mean(value))
ggplot(dum, aes(x = synch, y = meanProd, colour = model)) +
  labs(x = "Time", y = "Mean Realized Productivity Over Sim Period") +
  geom_boxplot() +
  scale_colour_manual(name = "Stock Recruit Model", values = colPal, 
                      guide = FALSE) +
  theme_sleekX() +
  facet_wrap(~cu, scale = "free_y")
```

No trends in CU-specific productivity either. So where are the trends in aggregate spawner abundance that are associated with increased synchrony coming from?


####Plot Aggregate PMs... again

Re-calculate aggregate performance metrics to see whether there is a bug in the model or else figure out where along the aggregation trends in performance appear. 

```{r reCalculateAggMetrics}
# Calculate aggregate recruit and spawner abundance
aggDat <- srFullDat %>% 
  group_by(trial, synch, yr) %>% 
  summarize(aggRecBY = sum(recBY),
            aggS = sum(spwn))

# Caculate summary stats over sim period (already filtered in srFullDat)
summAggDat <- aggDat %>% 
  gather(key = pm, value = value, aggRecBY, aggS) %>% 
  group_by(trial, synch, pm) %>% 
  summarize(meanPM = mean(value),
            geoMeanPM = exp(mean(log(value))),
            medPM = median(value)) %>% 
  gather(key = summStat, value = value, geoMeanPM, meanPM, medPM)

dum <- summAggDat %>% 
  filter(pm == "aggRecBY")

ggplot(dum, aes(x = synch, y = value)) +
  labs(x = "Time", y = "Summarized Recruit Abundance") +
  geom_boxplot() +
  theme_sleekX() +
  facet_wrap(~summStat)

aggDat %>% 
  group_by(synch) %>% 
  summarize(aggMedianRec = median(aggRecBY),
            aggMeanRec = mean(aggRecBY),
            aggGeoMeanRec = exp(mean(log(aggRecBY))))  
```

So the trends in reduced performance are not a bug in the model. They are present as soon as aggregate abundance is calculated and become much more apparent when looking at abundance over the simulation period **but only when using median or geometric mean PMs**. This suggests to me that there is some emergent property associated with the interaction between closed-loop sims and/or overcompensation plus the multivariate distribution that results in aggregate abundance declines at high levels of covariance. But if that's the case then surely it should be present prior to aggregating, correct?

Check some more plots. First distribution of aggregate recruitment without summary statistics, then the same but for CUs (subset of six).
```{r, unaggAbundance}
ggplot(aggDat, aes(x = synch, y = aggRecBY)) +
  labs(x = "Synch Treatment", y = "Unsummarized Aggregate Recruitment") +
  geom_boxplot() +
  theme_sleekX()

aggDat %>% 
  group_by(synch) %>% 
  summarize(median(aggRecBY),
            mean(aggRecBY),
            exp(mean(log(aggRecBY))))

ggplot(srFullDat %>% filter(cu < 7), aes(x = synch, y = recBY)) +
  labs(x = "Synch Treatment", y = "Unsummarized Individual Recruitment") +
  geom_boxplot() +
  theme_sleekX() +
  facet_wrap(~cu, scales = "free_y")

srFullDat %>% 
  group_by(synch) %>% 
  summarize(median(recBY),
            mean(recBY),
            exp(mean(log(recBY))))


```

So median abundance **does** decline, even prior to calculating summary statistics, but only only for the aggregate. Sean's code snippet suggests that this is a fundamental attribute of correlated log-normal variables, but I don't really know what the implications are for the paper (i.e. does this even make sense as an experimental framework anymore?). 