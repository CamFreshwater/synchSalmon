---
title: "Drivers of synchrony impacts"
author: "Cam Freshwater"
date: "February 6, 2019"
output: html_document
---

This is a rehash of the cuSpecificPMs_altSynchOMs.Rmd intended to address co-authors question about why high levels of synchrony result in reduced aggregate spawner abundance. Specifically, whether this is solely an artifact of using a skewed multivariate distribution are shared sources of mortality (i.e. en route and exploitation within an MU). To explore these impacts run four scenarios.

1) Reference
2) noExp - no exploitation
3) noMM - no migration (en route) mortality
4) noBoth - no exploitation OR migration mortality

Begin by examining reference productivity scenario to understand impacts of mortality OMs independently of productivity.

```{r readLibraries, message=FALSE, warning=FALSE, include=FALSE}
listOfPackages <- c("here", "parallel", "doParallel", "foreach", 
                    "tidyverse", "tictoc", "samSim")
newPackages <- listOfPackages[!(listOfPackages %in% 
                                  installed.packages()[ , "Package"])]
if (length(newPackages)) {
  install.packages(newPackages)
}
lapply(listOfPackages, require, character.only = TRUE)

simPar <- read.csv(here("data", "sox",
                         "fraserOMInputs_varyCorrNoMort.csv"),
                       stringsAsFactors = F)
cuPar <- read.csv(here("data/sox/fraserCUpars.csv"), stringsAsFactors=F)
srDat <- read.csv(here("data/sox/fraserRecDatTrim.csv"), stringsAsFactors=F)
catchDat <- read.csv(here("data/sox/fraserCatchDatTrim.csv"), stringsAsFactors=F)
ricPars <- read.csv(here("data/sox/pooledRickerMCMCPars.csv"), stringsAsFactors=F)
larkPars <- read.csv(here("data/sox/pooledLarkinMCMCPars.csv"), stringsAsFactors=F)
tamFRP <- read.csv(here("data/sox/tamRefPts.csv"), stringsAsFactors=F)

simParTrim <- simPar %>% 
  filter(scenario %in% c("ref", "noExp", "noMM", "noBoth"))
scenNames <- unique(simParTrim$scenario)
dirNames <- sapply(scenNames, function(x) paste(x, unique(simParTrim$species),
                                                sep = "_"))
```


```{r runSim, echo=TRUE, warning=FALSE}
# Define simulations to be run
nTrials <- 100

for (i in seq_along(dirNames)) {
  dirName <- dirNames[i]
  d <- subset(simParTrim, scenario == scenNames[i])
  simsToRun <- split(d, seq(nrow(d)))
  Ncores <- detectCores()
  cl <- makeCluster(Ncores - 1) #save one core
  registerDoParallel(cl)
  clusterEvalQ(cl, c(library(samSim)))
  clusterExport(cl, c("simsToRun","cuPar","nTrials","dirName",
                      "catchDat","srDat","ricPars","larkPars",
                      "tamFRP"), envir=environment())
  tic("run in parallel")
  parLapply(cl, simsToRun, function(x) {
    recoverySim(x, cuPar, catchDat=catchDat, srDat=srDat, variableCU=FALSE,
                ricPars, larkPars=larkPars, tamFRP=tamFRP, dirName=dirName,
                nTrials=nTrials, makeSubDirs=FALSE, random=FALSE)
    })
  stopCluster(cl) #end cluster
  toc()
}
```


```{r plotPMs, echo=TRUE, warning=FALSE}
vars <- c("medRecRY", "ppnCUUpper", "ppnCUExtant",
          "medCatch", "ppnYrsHighCatch", "stabilityCatch", 
          "medSpawners")
omNames <- scenNames

plotDat = NULL
for(h in seq_along(dirNames)) {
  agList <- genOutputList(dirNames[h], agg = TRUE)
  keyVar <- sapply(agList, function(x) unique(x$keyVar))
  plotOrder <- sapply(agList, function(x) unique(x$plotOrder))
  singleScen = NULL
  for (i in seq_along(vars)) {
    dum <- data.frame(om = rep(omNames[h], length.out = length(agList)),
                      var = rep(vars[i], length.out = length(agList)),
                      synch = as.factor(keyVar),
                      cat = as.factor(plotOrder),
                      avg = sapply(agList, function(x) median(x[,vars[i]])),
                      lowQ = sapply(agList, function(x) qLow(x[,vars[i]])),
                      highQ = sapply(agList, function(x) qHigh(x[,vars[i]])),
                      row.names = NULL
    )
    singleScen <- rbind(singleScen, dum)
  }
  rownames(singleScen) <- c()
  #merge multiple scenarios into one dataframe
  plotDat <- rbind(plotDat, singleScen) 
}

temp <- plotDat %>%
    filter(var == "medSpawners")
dotSize = 3; lineSize = 0.8; legSize = 0.8; axSize = 10

ggplot(temp, aes(x = synch, y = avg, ymin = lowQ, ymax = highQ)) +
    labs(x = "Synchrony Treatment", y = unique(temp$var), 
         color = "Sim.\nParameter\nValue") +
    geom_pointrange(fatten = dotSize, size = lineSize,
                    position = position_dodge(width = 0.65)) +
    facet_wrap(~om, scales = "fixed")
```

Declines in aggregate PMs still occur even under reference scenarios when both processes are taken out. However unlike skewed distribution the multivariate normal distribution does not result in a reduced mean as correlation strength increases.

```{r changesInMean, echo=TRUE, warning=FALSE}
f <- function(N = 15, r = 0.4, sigma = 0.2, skew = 0.65) {
  sig_mat <- matrix(as.numeric(sigma), nrow = 1, ncol = N)
  cov_mat <- (t(sig_mat) %*% sig_mat) * r
  diag(cov_mat) <- sigma^2
  x <- sn::rmst(1e5, xi = rep(0, N), Omega = cov_mat,
    alpha = rep(log(skew), N), nu = 200)
  as.numeric(x)
}

x <- f(10)
mean(x)

.r <- seq(0, 0.7, 0.05)
y <- purrr::map_df(.r, ~ data.frame(mean = mean(f(r = .x, skew = 0.65))))
y2 <- purrr::map_df(.r, ~ data.frame(mean = mean(f(r = .x, skew = 1))))
y$correlation <- .r
y2$correlation <- .r

library(ggplot2)
ggplot(y, aes(correlation, mean)) +
  geom_line()
```

Look into CU-specific relationships for any insight.

###Plot stock-recruit relationships
```{r stockRecCurves, echo = FALSE}
#Focus on simplest scenario where both exploitation and en route mortality have been removed (i.e. dirNames[4])
arrayNames <- sapply(dirNames[4], function(x) { #matrix of array names to be passed
  list.files(paste(here("outputs/simData"), x, sep="/"), 
             pattern = "\\Arrays.RData$")
})
synchNames <- c("high", "low", "med")
colPal <- c("#b2182b", "#2166ac")
names(colPal) <- c("larkin", "ricker")

srList <- lapply(seq_along(arrayNames), function(h) { 
  #medSynch treatment only
  datList <- readRDS(paste(here("outputs/simData"), dirNames[4], arrayNames[h], 
                           sep = "/"))
  sDat <- datList$S %>% 
    reshape2::melt() %>% 
    dplyr::rename("yr" = "Var1", "cu" =  "Var2", "trial" = "Var3", 
                  "spwn" = "value") %>% 
    mutate(synch = synchNames[h], om = "noBoth")  
  rDat <- datList$recBY %>% 
    reshape2::melt() %>% 
    dplyr::rename("yr" = "Var1", "cu" =  "Var2", "trial" = "Var3", 
                  "rec" = "value") %>% 
    mutate(synch = synchNames[h], om = "noBoth")
  srDat <- merge(sDat, rDat, by = c("yr", "cu", "trial", "synch", "om"))
  return(srDat)
}) 

srFull <- do.call(rbind, srList) %>% 
  filter(!yr < 60) %>% #focus on median sig treatment, sim period
  mutate(synch = as.factor(synch), 
         model = case_when(
           cu %in% c(1, 2, 6, 8, 9) ~ "larkin",
           TRUE ~ "ricker"
         )) %>% 
  mutate(synch = factor(synch, levels(synch)[c(2,3,1)]))
omNames <- unique(srFull$om)

drawTrials <- sample.int(max(srFull$trial), size = 1)
plotList <- lapply(seq_along(stkNames[1:6]), function(i) { 
    dum <- srFull %>% 
      filter(trial == drawTrials,
             cu == i) 
    r <- ggplot(dum, aes(x = spwn, y = rec, colour = model)) +
      labs(x = "Spawners", y = "Recruits", title = stkNames[i]) +
      geom_point(size = 1.25) +
      scale_colour_manual(name = "Stock Recruit Model", values = colPal, 
                          guide = FALSE) +
      theme_sleekX() +
      facet_wrap(~synch, nrow = 3, ncol = 1)
    return(r)
})

for (i in c(1, 4)) {
  srList <- ggarrange(plotList[[i]], plotList[[i+1]], plotList[[i+2]], 
            ncol = 3, nrow = 1, common.legend = TRUE, legend = "right", 
            align = "v", widths = c(1,1,1))
  annotate_figure(srList, 
                  left = text_grob("Recruits", rot = 90),
                  bottom = text_grob("Spawners"))
  print(srList)
}
```

Not a huge impact of reduced abundance. I think what we're seeing is the same phenomenon as before where aggregate abundances are dragged down by CU-specific draws from the distribution (i.e. spillover effects from the multivariate distribution), they're just much weaker when its not a skewed distribution.

Check recruitment deviations as before.

```{r recDeviations, echo = FALSE}
devList <- lapply(seq_along(arrayNames), function(h) { 
  #medSynch treatment only
  datList <- readRDS(paste(here("outputs/simData"), dirNames[4], arrayNames[h], 
                           sep = "/"))
  devDat <- datList$recDev %>% 
    reshape2::melt() %>% 
    dplyr::rename("yr" = "Var1", "cu" =  "Var2", "trial" = "Var3", 
                  "dev" = "value") %>% 
    mutate(synch = synchNames[h], om = "noBoth")
  return(devDat)
}) 

devFull <- do.call(rbind, devList) %>% 
  filter(!yr < 60) %>% #focus on median sig treatment, sim period
  mutate(synch = as.factor(synch), 
         model = case_when(
           cu %in% c(1, 2, 6, 8, 9) ~ "larkin",
           TRUE ~ "ricker"
         )) %>% 
  mutate(synch = factor(synch, levels(synch)[c(2,3,1)]))
omNames <- unique(devFull$om)

drawTrials <- sample.int(max(devFull$trial), size = 1)
plotList <- lapply(seq_along(stkNames[1:6]), function(i) { 
    dum <- devFull %>% 
      filter(trial == drawTrials,
             cu == i) %>% 
      group_by(synch) %>% 
      mutate(meanDev = mean(dev))
    r <- ggplot(dum, aes(x = yr, y = dev, colour = model)) +
      labs(x = "Time", y = "Recruitment Deviations", title = stkNames[i]) +
      geom_line(size = 1.25) +
      geom_hline(dum, mapping = aes(yintercept = meanDev), linetype = 2) +
      scale_colour_manual(name = "Stock Recruit Model", values = colPal, 
                          guide = FALSE) +
      theme_sleekX() +
      facet_wrap(~synch, nrow = 3, ncol = 1)
    return(r)
})

for (i in c(1, 4)) {
  devPlotList <- ggarrange(plotList[[i]], plotList[[i+1]], plotList[[i+2]], 
            ncol = 3, nrow = 1, common.legend = TRUE, legend = "right", 
            align = "v", widths = c(1,1,1))
  annotate_figure(devPlotList, 
                  left = text_grob("Recruits", rot = 90),
                  bottom = text_grob("Spawners"))
  print(devPlotList)
}
```