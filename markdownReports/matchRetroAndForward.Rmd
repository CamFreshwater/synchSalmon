---
title: "Observed Variability Patterns"
author: "Cam Freshwater"
date: "1/22/2019"
output: html_document
---

3 options for observed data

1.  Trimmed to time series that are full (~20 years with all 18 CUs)
2.  Model outputs from Sean's TMB analysis
3.  Calculated values with subset of CUs using `calcSynchMetrics` function

Option 1 will inflate synchrony relative to retro because only high period is being sampled; similar pattern with CVc but less dramatic. Option 2 and 3 should provide equivalent results to retrospective unless uncertainty can be incorporated so focusing on 2 for now.

2 options for simulated data

1.  Present variability among years (i.e one median per simulation year)
2.  Present variability among trial (i.e. one median per trial); NOT APPROPRIATE GIVEN OBSERVED DATA
3.  Present both

More fundamental question is why CVc in particular is so depressed relative to forward simulated reference values. Double check and confirm


```{r load data and run sims, include=FALSE}
# Check if required packages are installed and run
listOfPackages <- c("plyr", "here", "parallel", "doParallel", "foreach", 
                    "reshape2", "tidyverse", "gsl", "tictoc", "stringr", 
                    "synchrony", "zoo", "Rcpp", "RcppArmadillo", "sn", 
                    "sensitivity", "mvtnorm", "forcats", "ggpubr", "viridis", 
                    "samSim")

here <- here::here

newPackages <- listOfPackages[!(listOfPackages %in% 
                                  installed.packages()[ , "Package"])]
if(length(newPackages)) install.packages(newPackages)
lapply(listOfPackages, require, character.only = TRUE)

simPar <- read.csv(here("data/sox/fraserOMInputs_varyCorr.csv"), 
                   stringsAsFactors = F)
cuPar <- read.csv(here("data/sox/fraserCUpars.csv"), stringsAsFactors = F)
srDat <- read.csv(here("data/sox/fraserRecDatTrim.csv"), stringsAsFactors = F)
catchDat <- read.csv(here("data/sox/fraserCatchDatTrim.csv"), 
                     stringsAsFactors = F)
ricPars <- read.csv(here("data/sox/pooledRickerMCMCPars.csv"), stringsAsFactors = F)
larkPars <- read.csv(here("data/sox/pooledLarkinMCMCPars.csv"), stringsAsFactors = F)
tamFRP <- read.csv(here("data/sox/tamRefPts.csv"), stringsAsFactors = F)


## Define simulations to be run
nTrials <- 200
simParTrim <- subset(simPar,
                     scenario == "lowSig" | scenario == "medSig" |
                       scenario == "highSig")

scenNames <- unique(simParTrim$scenario)
dirNames <- sapply(scenNames, function(x) paste(x, unique(simParTrim$species),
                                                sep = "_"))

#matrix of array names to be passed
arrayNames <- sapply(dirNames, function(x) {
  list.files(paste(here("outputs/simData"), x, sep="/"), 
             pattern = "\\Arrays.RData$")
})

# recoverySim(simParTrim[1, ], cuPar, catchDat = catchDat, srDat = srDat,
#             variableCU = FALSE, ricPars, larkPars = larkPars, tamFRP = tamFRP, 
#             dirName = "test", nTrials = 5, multipleMPs = FALSE)

## Run simulation if appropriate data aren't local
for (i in seq_along(dirNames)) {
  dirName <- dirNames[i]
  d <- subset(simParTrim, scenario == scenNames[i])
  simsToRun <- split(d, seq(nrow(d)))
  Ncores <- detectCores()
  cl <- makeCluster(Ncores - 3) #save two cores
  registerDoParallel(cl)
  clusterEvalQ(cl, c(library(MASS),
                  library(here),
                  library(sensitivity),
                  library(mvtnorm),
                  library(scales), #shaded colors for figs
                  library(viridis), #color blind gradient palette
                  library(gsl),
                  library(dplyr),
                  library(Rcpp),
                  library(RcppArmadillo),
                  library(sn),
                  library(samSim)))
  #export custom function and objects
  clusterExport(cl, c("simsToRun", "recoverySim", "cuPar", "dirName", "nTrials",
                      "catchDat", "srDat", "ricPars", "dirName", "larkPars",
                      "tamFRP"), envir = environment())
  tic("run in parallel")
  parLapply(cl, simsToRun, function(x) {
    recoverySim(x, cuPar, catchDat = catchDat, srDat = srDat,
                variableCU = FALSE, ricPars, larkPars = larkPars,
                tamFRP = tamFRP, cuCustomCorrMat = NULL, dirName = dirName,
                nTrials = nTrials, multipleMPs = FALSE)
  })
  stopCluster(cl) #end cluster
  toc()
}


## Calculate synchrony indices if data aren't available
plotList = vector("list", length = length(dirNames))
# #stocks that are included in retrospective analysis 
# #(note these are matrix positions not stock ID numbers)
longStks <- c(1, 3, 4, 5, 6, 7, 8, 9, 16, 17)

tic("runParallel")
Ncores <- detectCores()
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(here), library(synchrony), library(zoo),
                   library(parallel), library(doParallel), library(foreach),
                   library(samSim)))
newAgTSList <- lapply(seq_along(dirNames), function (h) {
  #export custom function and objects
  clusterExport(cl, c("dirNames", "arrayNames", "calcSynchMetrics", "wtdCV",
                      "genOutputList", "longStks", "h"), envir = environment())
  listSynchLists <- parLapply(cl, 1:length(arrayNames[, h]), function(x) {
    datList <- readRDS(paste(here("outputs/simData"), dirNames[h],
                             arrayNames[x, h], sep = "/"))
    # Subset datList to only include longStks
    trimDatList <- datList
    # for (i in 4:length(datList)) {
    #   trimDatList[[i]] <- datList[[i]][ , longStks, ]
    # }
    synchList <- calcSynchMetrics(trimDatList, log = FALSE, corr = FALSE,
                                  weight = TRUE, windowSize = 12)
    synchList <- c(trimDatList$nameOM, synchList)
    names(synchList)[1] <- "opMod"
    return(synchList)
  }) #iterate across different OMs within a scenario
  # pull list of time series metrics estimated internally, then merge with
  # synch list generated above based on common op model
  agTSList <- genOutputList(dirNames[h], agg = TRUE, aggTS = TRUE)
  for(j in seq_along(agTSList)) {
    for(k in seq_along(listSynchLists)) {
      om <- agTSList[[j]]$opMod
      if (listSynchLists[[k]]$opMod == om) {
        agTSList[[j]] <- c(agTSList[[j]], listSynchLists[[k]][-1])
      }
    }
  }
  plotList[[h]] <- agTSList
}) #iterate across different scenarios
names(newAgTSList) <- dirNames
stopCluster(cl)
toc()

# saveRDS(newAgTSList, here("outputs/generatedData/synchTS",
#                           "retroForward_synchTSList.rda"))
```

```{r prep and clean interannual data, include=FALSE}
newAgTSList <- readRDS(here("outputs/generatedData/synchTS/synchTSList.rds"))

## Import tmb data to replace observed data with model outputs 
# Note: longPlotDat only
modOut <- readRDS(here("outputs", "generatedData", "tmbSynchEst.rds"))
modCVc <- modOut %>% 
  filter(term == "log_cv_s") %>% 
  select(est) %>% 
  unlist()
modSynch <- modOut %>% 
  filter(term == "logit_phi") %>% 
  select(est) %>% 
  unlist()


omNames <- rep(c("ref", "skewN", "skewT"), each = 3)
sigNames <- rep(c("lowSigma", "medSigma", "highSigma"), length.out = 9)
fullList <- sapply(seq_along(dirNames), function(h) {
  d <- newAgTSList[[h]]
  nYears <- d[[1]]$`nYears`
  simLength <- d[[1]]$`nYears` - d[[1]]$`nPrime`
  firstYear <- d[[1]]$`firstYr`
  start <- d[[1]]$`nPrime` + firstYear
  prodNames <- omNames[h]
  #subset list so it contains only sigma, synch and vars of interest,
  # calculate medians, and combine
  trimList <- lapply(d, function(x) {
    dat1 <- data.frame(sigmaOM = rep(sigNames[h], length.out = nYears),
                      synchOM = rep(x[["opMod"]], length.out = nYears),
                      prodOM = rep(prodNames, length.out = nYears),
                      year = seq(from = firstYear, 
                                 to = (firstYear + nYears - 1))
                      ) %>%
      mutate(sigmaOM = as.character(sigmaOM),
             synchOM = as.character(synchOM),
             medSynchRecBY = apply(x[["synchRecBY"]], 1, median),
             medCompCVRecBY = apply(x[["compCVRecBY"]], 1, median),
             medCorrRecBY = apply(x[["corrRecBY"]], 1, median)
      )
    dat1[dat1$year < start, c("sigmaOM", "synchOM")] <- "obsShort"
    dat2 <- dat1 %>%
      mutate(sigmaOM = factor(factor(sigmaOM), levels = c("obsShort", "lowSigma",
                                                          "medSigma",
                                                          "highSigma")),
             synchOM = factor(factor(synchOM), levels = c("obsShort", "lowSynch",
                                                          "medSynch", 
                                                          "highSynch"))
      ) 
    return(dat2)
  })
})
shortPlotDat <- do.call(rbind, fullList) %>% 
  filter(sigmaOM == "obsShort" | synchOM == "obsShort")


fullList <- sapply(seq_along(dirNames), function(h) {
  d <- newAgTSList[[h]]
  nYears <- d[[1]]$`nYears`
  simLength <- d[[1]]$`nYears` - d[[1]]$`nPrime`
  firstYear <- d[[1]]$`firstYr`
  start <- d[[1]]$`nPrime` + firstYear
  prodNames <- omNames[h]
  #subset list so it contains only sigma, synch and vars of interest,
  # calculate medians, and combine
  trimList <- lapply(d, function(x) {
    dat1 <- data.frame(sigmaOM = rep(sigNames[h], length.out = nYears),
                      synchOM = rep(x[["opMod"]], length.out = nYears),
                      prodOM = rep(prodNames, length.out = nYears),
                      year = seq(from = firstYear, 
                                 to = (firstYear + nYears - 1))
                      ) %>%
      mutate(sigmaOM = as.character(sigmaOM),
             synchOM = as.character(synchOM),
             medSynchRecBY = apply(x[["synchRecBY"]], 1, median),
             medCompCVRecBY = apply(x[["compCVRecBY"]], 1, median),
             medCorrRecBY = apply(x[["corrRecBY"]], 1, median)
      )
    dat1[dat1$year < start, c("sigmaOM", "synchOM")] <- "obsLong"
    dat2 <- dat1 %>%
      mutate(sigmaOM = factor(factor(sigmaOM), levels = c("obsLong", "lowSigma",
                                                          "medSigma",
                                                          "highSigma")),
             synchOM = factor(factor(synchOM), levels = c("obsLong", "lowSynch",
                                                          "medSynch", 
                                                          "highSynch"))
      ) 
    #replace observed data with estimates from TMB fitting
    #add NAs to front end to match length of sim time series
    diffLength <- length(dat2[dat2$sigmaOM == "obsLong" & 
                                dat2$synchOM == "obsLong", ]$medSynchRecBY) - 
      length(modCVc)
    modCVcTrim <- c(rep(NA, length.out = diffLength), modCVc) 
    modSynchTrim <- c(rep(NA, length.out = diffLength), modSynch)

    dat2[dat2$sigmaOM == "obsLong" & dat2$synchOM == "obsLong", 
         ]$medSynchRecBY <- modSynchTrim
    dat2[dat2$sigmaOM == "obsLong" & dat2$synchOM == "obsLong", 
         ]$medCompCVRecBY <- modCVcTrim
    return(dat2)
  })
})

plotDat <- do.call(rbind, fullList) %>% 
  rbind(shortPlotDat) %>%  #merge with observed data from shorter period
  mutate(sigmaOM = factor(sigmaOM, levels = c("obsShort", "obsLong", "lowSigma",
                                              "medSigma", "highSigma")),
         synchOM = factor(synchOM, levels = c("obsShort", "obsLong", "lowSynch",
                                              "medSynch", "highSynch")))
```

First look at observed CVc and phi for short and long periods relative to sim values using medians among trials (i.e. interannual variability).

```{r generate plots interannual}
start <- plotDat %>%
  filter(!sigmaOM == "obsLong") %>%
  summarise(min(year))
start <- start[[1]]

dum <- plotDat %>%
  filter(synchOM == "medSynch" | synchOM == "obsLong" | synchOM == "obsShort",
         prodOM == "ref",
         !is.na(medCompCVRecBY)) %>% 
  mutate(sigmaOM = recode(sigmaOM, "obsShort" = "Obs Short",
                          "obsLong" = "Obs Long",
                         "lowSigma" = "Low", 
                         "medSigma" = "Moderate",
                         "highSigma" = "High")
  )
colPal <- c("black", "grey", viridis(length(unique(dum$sigmaOM)) - 2, begin = 0, 
                             end = 1))
names(colPal) <- levels(dum$sigmaOM)
### Instead of plotting time series, make faceted box plot
q2 <- ggplot(dum, aes(x = sigmaOM, y = medCompCVRecBY, fill = sigmaOM)) +
  labs(x = "Component Variability Scenario", y = "Median CVc of Returns", 
       title = NULL) +
  geom_boxplot(size = 1, alpha = 0.5) +
  geom_vline(xintercept = start, color = "black", linetype = 3, size = 1) +
  guides(fill = FALSE, color = FALSE) +
  scale_fill_manual(name = "Operating Model", values = colPal) +
  theme_sleekX(position = "standard", legendSize = 0.9, axisSize = 12)

dum2 <- plotDat %>%
  filter(sigmaOM == "medSigma" | synchOM == "obsLong" | synchOM == "obsShort",
         prodOM == "ref", !is.na(medSynchRecBY)) %>% 
  mutate(synchOM = recode(synchOM, "obsShort" = "Obs Short",
                          "obsLong" = "Obs Long", 
                          "lowSynch" = "Low", 
                          "medSynch" = "Moderate",
                          "highSynch" = "High")
  )
colPal2 <- c("black", "grey", viridis(length(unique(dum$sigmaOM)) - 2, 
                                      begin = 0, end = 1))
names(colPal2) <- levels(dum2$synchOM)
p2 <- ggplot(dum2, aes(x = synchOM, y = medSynchRecBY, fill = synchOM)) +
  labs(x = "Synchrony Scenario",
       y = expression(paste("Median ", phi, " of Returns")),
       title = NULL) +
  geom_boxplot(size = 1, alpha = 0.5) +
  geom_vline(xintercept = start, color = "black", linetype = 3, size = 1) +
  guides(fill = FALSE, color = FALSE) +
  scale_fill_manual(values = colPal2) +
  theme_sleekX(position = "standard", legendSize = 0.9, axisSize = 12)

ggarrange(q2, p2, nrow = 2, ncol = 1, heights = c(1, 1.2))
```

As expected, longer TS result in greater interannual variability and lower medians (i.e. fewer years during high aggregate variability phase). While it's reasonable that observed values encompass plotted, I'm concerned that the medians draw criticism because they're so much lower than expected.

Alternative possibility is to divide observed data into early and late periods.

```{r generate plots with two periods}
twoPeriodDat <- plotDat %>% 
  filter(!sigmaOM == "obsShort") %>% 
  mutate(sigmaOM = as.character(sigmaOM),
         synchOM = as.character(synchOM))
twoPeriodDat[twoPeriodDat$year < (2011), c("sigmaOM", "synchOM")] <- "obsLate"
twoPeriodDat[twoPeriodDat$year < (2011 - 20), c("sigmaOM", "synchOM")] <-
  "obsEarly"

twoPeriodDat <- twoPeriodDat %>% 
  mutate(sigmaOM = factor(sigmaOM, levels = c("obsEarly", "obsLate", "lowSigma",
                                              "medSigma", "highSigma")),
         synchOM = factor(synchOM, levels = c("obsEarly", "obsLate", "lowSynch",
                                              "medSynch", "highSynch")))

dum <- twoPeriodDat %>%
  filter(synchOM == "medSynch" | synchOM == "obsEarly" | synchOM == "obsLate",
         prodOM == "ref",
         !is.na(medCompCVRecBY)) %>% 
  mutate(sigmaOM = as.factor(sigmaOM),
         synchOM = as.factor(synchOM)) %>% 
  mutate(sigmaOM = recode(sigmaOM, "obsEarly" = "Obs Early",
                          "obsLate" = "Obs Late",
                         "lowSigma" = "Low", 
                         "medSigma" = "Moderate",
                         "highSigma" = "High")
  )
colPal <- c("black", "grey", viridis(length(unique(dum$sigmaOM)) - 2, begin = 0, 
                             end = 1))
names(colPal) <- levels(dum$sigmaOM)
### Instead of plotting time series, make faceted box plot
q2 <- ggplot(dum, aes(x = sigmaOM, y = medCompCVRecBY, fill = sigmaOM)) +
  labs(x = "Component Variability Scenario", y = "Median CVc of Returns", 
       title = NULL) +
  geom_boxplot(size = 1, alpha = 0.5) +
  geom_vline(xintercept = start, color = "black", linetype = 3, size = 1) +
  guides(fill = FALSE, color = FALSE) +
  scale_fill_manual(name = "Operating Model", values = colPal) +
  theme_sleekX(position = "standard", legendSize = 0.9, axisSize = 12)

dum2 <- twoPeriodDat %>%
  filter(sigmaOM == "medSigma" | sigmaOM == "obsEarly" | sigmaOM == "obsLate",
         prodOM == "ref",
         !is.na(medSynchRecBY)) %>% 
  mutate(synchOM = as.factor(synchOM),
         sigmaOM = as.factor(sigmaOM)) %>% 
  mutate(synchOM = recode(synchOM, "obsEarly" = "Obs Early",
                          "obsLate" = "Obs Late", 
                          "lowSynch" = "Low", 
                          "medSynch" = "Moderate",
                          "highSynch" = "High")
  )
colPal2 <- c("black", "grey", viridis(length(unique(dum$sigmaOM)) - 2, 
                                      begin = 0, end = 1))
names(colPal2) <- levels(dum2$synchOM)
p2 <- ggplot(dum2, aes(x = synchOM, y = medSynchRecBY, fill = synchOM)) +
  labs(x = "Synchrony Scenario",
       y = expression(paste("Median ", phi, " of Returns")),
       title = NULL) +
  geom_boxplot(size = 1, alpha = 0.5) +
  geom_vline(xintercept = start, color = "black", linetype = 3, size = 1) +
  guides(fill = FALSE, color = FALSE) +
  scale_fill_manual(values = colPal2) +
  theme_sleekX(position = "standard", legendSize = 0.9, axisSize = 12)

ggarrange(q2, p2, nrow = 2, ncol = 1, heights = c(1, 1.2))
```