---
title: "Interaction between synchrony and PMs"
author: "Cam Freshwater"
date: "February 12, 2019"
output: html_document
---

Two unusual patterns associated with increasing synchrony. 

#### 1) Increasing ppn of CUs above their BM
Although median aggregate return abundance declines with increasing synchrony, the proportion of CUs above their biological BM increases. This Rmd looks at different data patterns to try to determine why that may be.

```{r loadData}
require(samSim); require(tidyverse); require(here)

simPar <- read.csv(here("data/sox/fraserOMInputs_varyCorr.csv"), 
                   stringsAsFactors = F)

simParTrim <- subset(simPar, scenario %in% "medSig")

scenNames <- unique(simParTrim$scenario)
dirNames <- sapply(scenNames, function(x) paste(x, unique(simParTrim$species),
                                                sep = "_"))

agList <- genOutputList(dirNames[1], agg = TRUE, aggTS = TRUE)

makeData <- function(list, variable) {
  plotList <- lapply(list, function (i) {
    dum <- i[[variable]]
    nTrials <- ncol(dum)
    nYears <- nrow(dum)
    colnames(dum) <- seq(1, nTrials, by = 1)
    dat <- data.frame(synch = rep(unique(i[["opMod"]]), 
                                  length.out = nTrials * nYears),
                      years = rep(seq(1, nYears, by = 1), times = nTrials),
                      trial = rep(seq(1, nTrials, by = 1), each = nYears)
    )
    dum2 <- dum %>%
        as.data.frame() %>%
        gather(key = key, value = varName) 
    cbind(dat, dum2) %>% 
      select(-key)
  })
  outData <- do.call(rbind, plotList)
  row.names(outData) <- NULL
  return(outData)
}

ppnUpDat <- makeData(agList, "Prop Above Upper BM") %>% 
  dplyr::rename(ppnUp = varName) %>% 
  filter(!is.na(ppnUp)) %>%
  dplyr::mutate(synch = factor(synch, levels = c("lowSynch", "medSynch",
                                                 "highSynch")))
```

``` {r plotPpnTSByTrial}
drawTrials <- sample.int(max(ppnUpDat$trial), size = 9, replace = FALSE)

trimDat <- ppnUpDat %>% 
  filter(trial %in% drawTrials)

ggplot(trimDat, aes(x = years, y = ppnUp, linetype = synch)) +
  geom_line() +
  theme_sleekX() +
  facet_wrap(~trial, scales = "free_y")

meanDat <- ppnUpDat %>%
  dplyr::group_by(trial, synch) %>% 
  dplyr::summarize(meanUp = mean(ppnUp),
                   medUp = median(ppnUp))

ggplot(meanDat, aes(x = synch, y = medUp)) +
  geom_boxplot() +
  theme_sleekX()
```

High synchrony trials do seem to produce a greater number of years with CUs above the BM on average and boxplots, which recalculate the summary statistics produced internally by the model, show a similar trend. What I think may be going is that synchronized good recruitment events are enough to push a couple more CUs past the threshold; conversely synchronized bad events don’t strongly influence low status stocks (because they’re already low) or high status stocks (they’re far enough away from the edge to be ok). Need to dig in more but not sure how to tease it apart. 

Try simulating some data to figure this out. First just draw from a multivariate normal distribution.

```{r simData}
require(tidyverse); require(ggplot2)

f <- function(N = 15, r = 0.4, sigma = 0.2) {
  sig_mat <- matrix(as.numeric(sigma), nrow = 1, ncol = N)
  cov_mat <- (t(sig_mat) %*% sig_mat) * r
  diag(cov_mat) <- sigma^2
  x <- sn::rmst(1e4, xi = rep(0, N), Omega = cov_mat,
    alpha = rep(0, N), nu = 1000)
  as.numeric(x)
}

x <- f(15)
mean(x)

.r <- seq(0, 0.7, 0.05)
thresh <- 0.2
tempList <- lapply(seq_along(.r), function(i) {
  dum <- f(r = .r[i])
  data.frame(r = .r[i],
             mean = mean(dum),
             overT = length(dum[dum > thresh]) / length(dum))
})
dum <- do.call(rbind, tempList)
ggplot(dum, aes(x = r, y = overT)) +
  geom_point() +
  theme_sleekX()
```

No obvious patterns when drawing from the MVN distribution itself. Check with a simple Ricker model where threshold is based on SR parameters.

```{r simpleRickerSim}
cuPars <- read.csv(here("data", "sox", "fraserCUPars.csv")) %>% 
  filter(model == "ricker")
srDat <- read.csv(here("data", "sox", "fraserRecDatTrim.csv")) %>% 
  filter(stk %in% cuPars$stk)

nStks <- length(unique(cuPars$stkName))
alpha <- cuPars$alpha
beta <- cuPars$beta0
sigma <- cuPars$sigma
stks <- cuPars$stkName
#use smsy as threshold
Smsy <- data.frame(CU = stks,
                   Smsy = (1 - gsl::lambert_W0(exp(1 - alpha))) / beta)

N = 1000
meanS <- srDat %>% 
  group_by(stk) %>% 
  summarize(meanS = mean(totalSpwn, na.rm = TRUE)) %>% 
  select(meanS) %>%
  unlist() %>% 
  as.numeric()

simpleRicker <- function(S, a, b, error) {
    S * exp(a - b * S) * exp(error)
}

#Generate estimates of recruitment based on low productivity parameters
ricSim <- function(N, S = meanS, alphas = alpha, betas = beta, 
                   sigmas = sigma, r = 0.5, stkNames = stks) {
  nStks <- length(stkNames)

  sigMat <- matrix(as.numeric(sigmas), nrow = 1, ncol = nStks)
  covMat <- (t(sigMat) %*% sigMat) * r
  diag(covMat) <- sigmas^2

  trialSeq <- seq(1, N, by = 1)
  outList <- lapply(1:N, function (x) {
    err <- sn::rmst(n = 1, xi = rep(0, nStks), Omega = covMat, 
                    alpha = rep(0, nStks), nu = 1000) %>%
      as.numeric()
    data.frame(trial = trialSeq[x],
               CU = stkNames,
               rec = simpleRicker(meanS, alphas, betas, error = err)) 
  })
  outDat <- do.call(rbind, outList)
  return(outDat)
}

## Loop over and explore
rSeq <- seq(0, 0.7, by = 0.1)
outList <- lapply(seq_along(rSeq), function(x) {
  set.seed(456)
  dum <- ricSim(N = 10000, r = rSeq[x], sigmas = sigma) %>% 
    mutate(r = as.factor(rSeq[x]),
           trial = as.factor(trial))
})
dum <- do.call(rbind, outList)

dum2 <- merge(dum, Smsy, by = "CU")
t <- dum2 %>%
  dplyr::group_by(r) %>% 
  summarize(ppnOver = length(which(rec > Smsy)) / length(rec))
```

Hmm opposite pattern to that observed in closed-loop sim. Check out no fishing mortality and no en route mortality sim runs.

``` {r noMortSims}
simPar <- read.csv(here("data/sox/fraserOMInputs_varyCorrNoMort.csv"),
                   stringsAsFactors = F)
simParTrim <- simPar %>% 
  filter(scenario %in% c("ref", "noExp", "noMM", "noBoth"))
scenNames <- unique(simParTrim$scenario)
dirNames <- sapply(scenNames, function(x) paste(x, unique(simParTrim$species), 
                                                sep = "_"))

outList <- lapply(seq_along(dirNames), function(i) {
  agList <- genOutputList(dirNames[i], agg = TRUE)
  dum <- lapply(agList, function(x) {
    x %>% 
      select(opMod, trial, ppnCUUpper, ppnCULower, ppnMixedOpen) %>% 
      dplyr::rename(synch = opMod) %>% 
      mutate(opMod = as.factor(scenNames[i]))
  })
  do.call(rbind, dum)
})
outDat <- do.call(rbind, outList) %>% 
  gather(key = pm, value = value, ppnCUUpper, ppnCULower, ppnMixedOpen) %>% 
  mutate(synch = factor(factor(synch), levels = c("lowSynch", "medSynch",
                                                   "highSynch")))

plotDat <- outDat %>% 
  filter(pm == "ppnCUUpper")

ggplot(plotDat, aes(x = synch, y = value)) +
  geom_boxplot() +
  theme_sleekX() +
  facet_wrap(~opMod)
```

**Yes** appear to be driven by exploitation so that trends disappear when ER is set to 0. I.e. when populations are highly synchronized, HCRs are more effective at limiting overharvest (slightly).

#### 2) Increasing CU-specific abundance
```{r lookAtCUTrends}
cuPar <- read.csv(here("data/sox/fraserCUPars.csv"), stringsAsFactors = F)

cuList <- genOutputList(dirNames[1], agg = FALSE)

arrayNames <- list.files(paste(here("outputs/simData"), dirNames[1], sep="/"),
                         pattern = "\\Arrays.RData$")
tsLists <- lapply(1:length(arrayNames), function(x) {
  readRDS(paste(here("outputs/simData"), dirNames[1], arrayNames[x], sep = "/"))
})

plotList <- lapply(tsLists, function (i) {
  dum <- i[["S"]]
  synchOM <- i[["nameOM"]]
  colnames(dum) <- abbreviate(cuPar$stkName, minlength = 4)
  dum %>% 
    reshape2::melt() %>% 
    dplyr::rename("yr" = "Var1", "cu" =  "Var2", "trial" = "Var3", 
                  "spwn" = "value") %>% 
    mutate(synch = i[["nameOM"]]) %>% 
    filter(yr > i[["nPrime"]])
})
sDat <- do.call(rbind, plotList) %>% 
  mutate(synch = factor(synch, levels = c("lowSynch", "medSynch",
                                                 "highSynch")))

drawTrials <- sample.int(max(sDat$trial), size = 4, replace = FALSE)
trimDat <- sDat %>% 
  filter(trial %in% drawTrials,
         cu %in% c("Chlk", "Clts", "L.Sh", "Hrrs"))

for(i in seq_along(drawTrials)) {
  p <- ggplot(trimDat %>% filter(trial == drawTrials[i]), 
              aes(x = yr, y = spwn, colour = synch)) +
    geom_line() +
    theme_sleekX() +
    ggtitle(drawTrials[i]) +
    facet_wrap(~cu, scales = "free_y")
  print(p)
}

meanDat <- sDat %>%
  filter(cu %in% c("Chlk", "Clts", "L.Sh", "Hrrs")) %>% 
  dplyr::group_by(trial, cu, synch) %>% 
  dplyr::summarize(medSpwn = median(spwn),
                   meanSpwn = mean(spwn))

ggplot(meanDat, aes(x = synch, y = meanSpwn)) +
  geom_boxplot() +
  theme_sleekX() +
  facet_wrap(~cu, scales = "free_y")
```

Difficult to tell from time series plots whether high synchrony results in greater spawner abundance than low, even though box plots seem to confirm it. Potentially driven by small sample size? **Confirmed after running with 1000 sims that patttern disappears**


#### 3) Interaction between sigma and synch

Why is pattern in synchrony (i.e. decreased recruit abundance) independent of sigma strength. 
``` {r sigAndSynchSim}
sigScalar <- c(0.5, 1, 1.5)
rSeq <- seq(0, 0.6, by = 0.3)
outterList <- lapply(seq_along(sigScalar), function(y) {
  outList <- lapply(seq_along(rSeq), function(x) {
    set.seed(456)
    dum <- ricSim(N = 5000, r = rSeq[x], sigmas = sigma * sigScalar[y]) %>% 
      mutate(sigScalar = as.factor(sigScalar[y]),
             r = as.factor(rSeq[x]),
             trial = as.factor(trial))
  })
  dum <- do.call(rbind, outList)
})
dum2 <- do.call(rbind, outterList) %>% 
  filter(CU == levels(CU)[1:4])

stkSubset <- unique(dum2$CU)
for (i in seq_along(stkSubset)) {
  p <- ggplot(dum2 %>% filter(CU==stkSubset[i]), 
         aes(x=r, y=rec)) + 
    geom_boxplot() +
    theme_sleekX() +
    facet_wrap(~sigScalar, scales = "free_y")
  print(p)
}

medRec <- dum2 %>% 
  group_by(CU, r, sigScalar) %>% 
  summarize(medRec = median(rec))
medRec %>% 
  group_by(CU, sigScalar) %>% 
  summarize(maxMedDiff = max(medRec) - min(medRec))
```

Difference between synchrony treatments does increase with sigma. Confirm by looking at aggregate abundance.

``` {r sigAndSynchAggSim}
dum3 <- do.call(rbind, outterList) %>% 
  group_by(trial, sigScalar, r) %>% 
  summarize(aggRec = sum(rec))

ggplot(dum3, aes(x=r, y=aggRec)) + 
    geom_boxplot() +
    theme_sleekX() +
    facet_wrap(~sigScalar, scales = "free_y")

medAggRec <- dum3 %>% 
  group_by(r, sigScalar) %>% 
  summarize(medAggRec = median(aggRec))
medAggRec %>% 
  group_by(sigScalar) %>% 
  summarize(maxMedDiff = max(medAggRec) - min(medAggRec))
```

Difference in median aggregate recruitment between synchrony treatments also increases with sigma. Confirm by looking at reference simulation runs.

``` {r sigAndSynchAggFullSim}
simPar <- read.csv(here("data/sox/fraserOMInputs_varyCorr.csv"), 
                   stringsAsFactors = F)
simParTrim <- subset(simPar, scenario %in% c("lowSig", "medSig", "highSig"))

scenNames <- unique(simParTrim$scenario)
dirNames <- sapply(scenNames, function(x) paste(x, unique(simParTrim$species),
                                                sep = "_"))

outList <- lapply(seq_along(dirNames), function(i) {
  agList <- genOutputList(dirNames[i], agg = TRUE)
  dum <- lapply(agList, function(x) {
    x %>% 
      select(opMod, trial, medRecRY, medRecBY, ppnCUUpper, ppnCUExtant) %>% 
      dplyr::rename(synch = opMod) %>% 
      mutate(sigma = as.factor(scenNames[i]))
  })
  do.call(rbind, dum)
})
outDat <- do.call(rbind, outList) %>% 
  gather(key = pm, value = value, -synch, -trial, -sigma) %>% 
  mutate(synch = factor(factor(synch), levels = c("lowSynch", "medSynch",
                                                   "highSynch")),
         sigma = factor(factor(sigma), levels = c("lowSig", "medSig",
                                                   "highSig")))

vars <- unique(outDat$pm)
for(i in seq_along(vars)) {
  plotDat <- outDat %>% 
    filter(pm == vars[i])
  p <- ggplot(plotDat, aes(x = synch, y = value)) +
    geom_boxplot() +
    theme_sleekX() +
    ggtitle(vars[i]) +
    facet_wrap(~sigma)
  print(p)
}

medPpn <- outDat %>%
  filter(pm == "ppnCUUpper") %>% 
  group_by(synch, sigma) %>% 
  summarize(medPpn = median(value))
medPpn %>% 
  group_by(sigma) %>% 
  summarize(maxMedDiff = max(medPpn) - min(medPpn))
```
